# ã¯ã˜ã‚ã«
vueã®ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ãƒ¼ãŒã©ã®ã‚ˆã†ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã‹ã‚’ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’èª­ã¿ãªãŒã‚‰ç°¡æ˜“ç‰ˆrefã‚’å®Ÿè£…ã—ãŸã®ã§ã€å®Ÿè£…ã¨ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®ä¸­èº«ã«ã¤ã„ã¦ã¾ã¨ã‚ã€‚

# vueã«ãŠã‘ã‚‹refã®å®Ÿè£…
vueå…¬å¼ã®[ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã®æ¢æ±‚](https://ja.vuejs.org/guide/extras/reactivity-in-depth.html#how-reactivity-works-in-vue)ã‚’èª­ã‚€ã¨ä»Šå›å®Ÿè£…ã™ã‚‹refã®ä¸­èº«ã«ã¤ã„ã¦ä»¥ä¸‹ã®ã‚ˆã†ã«è¨˜è¿°ãŒã‚ã‚Šã¾ã™ã€‚
```js
function ref(value) {
  const refObject = {
    get value() {
      track(refObject, 'value')
      return value
    },
    set value(newValue) {
      value = newValue
      trigger(refObject, 'value')
    }
  }
  return refObject
}

let activeEffect

function track(target, key) {
  if (activeEffect) {
    const effects = getSubscribersForProperty(target, key)
    effects.add(activeEffect)
  }
}

function trigger(target, key) {
  const effects = getSubscribersForProperty(target, key)
  effects.forEach((effect) => effect())
}

function whenDepsChange(update) {
  const effect = () => {
    activeEffect = effect
    update()
    activeEffect = null
  }
  effect()
}
```
ä¸Šè¨˜ã®ã‚³ãƒ¼ãƒ‰ã®ã‚ˆã†ã«ã€refã®ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã¯ã€
1. refã®ä½œæˆæ™‚ã€å—ã‘å–ã£ãŸvalueã‚’getterã¨setterã‚’ã‚‚ã¤objectã§ãƒ©ãƒƒãƒ—ã™ã‚‹
2. getterã«ã‚¢ã‚¯ã‚»ã‚¹ãŒã‚ã‚Œã°ã€ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸé–¢æ•°ï¼ˆeffectï¼šå‰¯ä½œç”¨ï¼‰ã‚’è¨˜éŒ²ã—ã¦ãŠã
3. setterã«ã‚ˆã‚Šå€¤ã®æ›´æ–°ãŒè¡Œã‚ã‚ŒãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ã€è¨˜éŒ²ã—ã¦ãŠã„ãŸé–¢æ•°ï¼ˆeffectï¼‰ã‚’å®Ÿè¡Œã™ã‚‹
ä»¥ä¸Šã®ã‚ˆã†ãªãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã§å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚

ã—ã‹ã—ã€ã“ã®ç°¡ç•¥åŒ–ã•ã‚ŒéããŸrefã§ã¯ã©ã®ã‚ˆã†ã«refã«ã‚¢ã‚¯ã‚»ã‚¹ãŒã‚ã£ãŸé–¢æ•°ã‚’è¨˜éŒ²ã—ã¦ãŠãã®ã‹ãŒã‚ˆãã‚ã‹ã‚Šã¾ã›ã‚“ã€‚

ä»Šå›ã¯[vueã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰](https://github.com/vuejs/core/blob/2857a59e61c9955e15553180e7480aa40714151c/packages/reactivity/src/ref.ts)ã‚’èª­ã¿ã¤ã¤å®Ÿè£…ã—ãŸç°¡æ˜“ç‰ˆï¼ˆãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚ˆã‚Šã¯ã¡ã‚‡ã£ã¨å®Ÿè£…ãŒå¢—ãˆãŸï¼‰ã‚’å®Ÿè£…ã—ãªãŒã‚‰ä¸­èº«ã‚’æ¢ã£ã¦ã¿ã¾ã™ã€‚


# MyRefã®å®Ÿè£…

## ref()
ãã‚Œã§ã¯å®Ÿéš›ã®ã‚³ãƒ¼ãƒ‰ã‚’è¦‹ã¤ã¤ã€ãã“ã‹ã‚‰ã‚³ã‚¢ã®éƒ¨åˆ†ã ã‘ã‚’æŠœã„ã¦ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã‚’å®Ÿè£…ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚
ã¾ãšã€æ¯æ—¥ãŠä¸–è©±ã«ãªã£ã¦ã„ã‚‹`ref()`ã®å®Ÿè£…ã‹ã‚‰è¦‹ã¦ã¿ã¾ã™ã€‚
```ref.ts
/**
 * Takes an inner value and returns a reactive and mutable ref object, which
 * has a single property `.value` that points to the inner value.
 *
 * @param value - The object to wrap in the ref.
 * @see {@link https://vuejs.org/api/reactivity-core.html#ref}
 */
export function ref<T extends Ref>(value: T): T
export function ref<T>(value: T): Ref<UnwrapRef<T>>
export function ref<T = any>(): Ref<T | undefined>
export function ref(value?: unknown) {
  return createRef(value, false)
}
```
`createRef`ã‚’èª­ã‚“ã§è¿”ã—ã¦ã„ã‚‹ã ã‘ã§ã™ã­ã€‚
ãã‚Œã§ã¯åŒã˜ãƒ•ã‚¡ã‚¤ãƒ«ã«å®Ÿè£…ãŒã‚ã‚‹`createRef`ã‚’èª­ã‚“ã§ã¿ã¾ã™ã€‚

```ref.ts
function createRef(rawValue: unknown, shallow: boolean) {
  if (isRef(rawValue)) {
    return rawValue
  }
  return new RefImpl(rawValue, shallow)
}
```
å—ã‘å–ã£ãŸå€¤ãŒrefã§ã‚ã‚Œã°ãã®ã¾ã¾è¿”ã—ã€refã§ãªã‘ã‚Œã°`RefImpl`ã¨ã„ã†classã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¦ã„ã‚‹ã‚ˆã†ã§ã™ã€‚

ç°¡æ˜“ç‰ˆã¯å€¤ã‚’å—ã‘å–ã£ã¦`RefImpl`ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã™ã“ã¨ã«ã—ã¾ã™ã€‚
```myref.ts
function ref<T>(value: T) {
    return new RefImpl(value);
}
```

## RefImpl
ã§ã¯`RefImpl` classã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚


```ref.ts
class RefImpl<T> {
  private _value: T
  private _rawValue: T

  public dep?: Dep = undefined
  public readonly __v_isRef = true

  constructor(
    value: T,
    public readonly __v_isShallow: boolean
  ) {
    this._rawValue = __v_isShallow ? value : toRaw(value)
    this._value = __v_isShallow ? value : toReactive(value)
  }

  get value() {
    trackRefValue(this)
    return this._value
  }

  set value(newVal) {
    const useDirectValue =
      this.__v_isShallow || isShallow(newVal) || isReadonly(newVal)
    newVal = useDirectValue ? newVal : toRaw(newVal)
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal
      this._value = useDirectValue ? newVal : toReactive(newVal)
      triggerRefValue(this, newVal)
    }
  }
}
```
ã“ã‚ŒãŒrefã®æœ¬ä½“ã§ã€console.logã§ä»»æ„ã®refã®ä¸­èº«ã‚’è¦‹ã¦ã¿ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚
![ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ 2023-10-14 0.16.27.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2724475/6fe0a8a1-ec8a-ef91-fc9c-3f7e041fa14f.png)


ã ã„ã¶ã‚³ãƒ¼ãƒ‰ãŒé•·ããªã£ã¦ã—ã‚“ã©ããªã£ã¦ãã¾ã—ãŸã€‚ã—ã‹ã—vueå…¬å¼ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã‚ã‚‹ã‚³ãƒ¼ãƒ‰ã¨æœ¬è³ªçš„ã«ã¯åŒã˜ã§ã€getterã¨setterã§valueã‚’ãƒ©ãƒƒãƒ—ã—ã¦ã„ã¾ã™ã€‚vueå…¬å¼ã‹ã‚‰ã®é•ã„ã§èˆˆå‘³æ·±ã„ã®ã¯ã€depã®å­˜åœ¨ã§ã™ã€‚ã“ã‚Œã¯ä½•ã§ã—ã‚‡ã†ï¼Ÿ

```dep.ts
export type Dep = Set<ReactiveEffect> & TrackedMarkers
/**
 * wasTracked and newTracked maintain the status for several levels of effect
 * tracking recursion. One bit per level is used to define whether the dependency
 * was/is tracked.
 */
type TrackedMarkers = {
  /**
   * wasTracked
   */
  w: number
  /**
   * newTracked
   */
  n: number
}
```
depã¯`ReactiveEffect`ã®Setã®ã‚ˆã†ã§ã™ã€‚`ReactiveEffect`ã¯æœ€åˆã®å…¬å¼ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã‚‚å‡ºã¦ãã¾ã—ãŸãŒã€

> ä¾å­˜é–¢ä¿‚ã‚’è‡ªå‹•çš„ã«è¿½è·¡ã—ã€ä¾å­˜é–¢ä¿‚ãŒå¤‰æ›´ã•ã‚Œã‚‹ãŸã³ã«å†å®Ÿè¡Œã™ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ

ã®ã“ã¨ã§ã™ã€‚è¦ã™ã‚‹ã«refã‚’åˆ©ç”¨ã—ã¦ã„ã¦ã€refã®å€¤ãŒå¤‰æ›´ã•ã‚ŒãŸã¨ãã«å‰¯ä½œç”¨ã¨ã—ã¦å®Ÿè¡Œã™ã‚‹å¿…è¦ã®ã‚ã‚‹é–¢æ•°ã®é›†åˆã§ã™ã€‚
ä¸€æ—¦`ReactiveEffect`ã®å®Ÿè£…ã¯ç½®ã„ã¦ãŠã„ã¦ã€å…ˆã«ã“ã“ã¾ã§ã®`Dep`ã€`RefImple`ã®ç°¡æ˜“ç‰ˆã‚’ä½œã‚Šã¾ã™ã€‚

```myref.ts
//Depã¯ReactiveEffectã®Set
type Dep = Set<ReactiveEffect>;

//Refã®å®Ÿè£…
class RefImpl<T> {
  //reactiveã«ã—ãŸã„å€¤ã‚’_valueã«ä¿æŒ
  private _value: T;
  //ã“ã®refã«ä¾å­˜ã—ã¦ã„ã‚‹effectã®é›†åˆ
  public dep: Dep = new Set();

  constructor(value: T) {
    this._value = value;
  }

  //.valueã«getterã§ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã¨ãã«ã€activeEffectã‚’depã«è¿½åŠ 
  get value() {
    trackEffects(this.dep);
    return this._value;
  }

  //.valueã«setterã§å€¤ã‚’æ›´æ–°ã™ã‚‹ã¨ãã«ã€depã«ç™»éŒ²ã—ãŸeffectã‚’å®Ÿè¡Œ
  set value(newVal) {
    this._value = newVal;
    triggerEffects(this.dep);
  }
}

//activeEffectã‚’depã«ç™»éŒ²ã™ã‚‹
function trackEffects(dep: Dep) {
  if (activeEffect) dep.add(activeEffect);
}

//depã®ä¸­ã®effectã‚’é †ç•ªã«å®Ÿè¡Œ
function triggerEffects(dep: Dep) {
  for (const effect of dep) {
    effect.run();
  }
}
```

## ReactiveEffect
å®Ÿéš›ã®`ReactiveEffect`ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ï¼ˆ100è¡Œä»¥ä¸Šã‚ã‚‹ã®ã§ã€ä¸€éƒ¨çœç•¥ã—ã¦ã„ã¾ã™ï¼‰ã€‚

```effect.ts
export let activeEffect: ReactiveEffect | undefined

export class ReactiveEffect<T = any> {
  active = true
  deps: Dep[] = []
  parent: ReactiveEffect | undefined = undefined

  // ä¸€éƒ¨çœç•¥

  constructor(
    public fn: () => T,
    public scheduler: EffectScheduler | null = null,
    scope?: EffectScope
  ) {
    recordEffectScope(this, scope)
  }

  run() {
    if (!this.active) {
      return this.fn()
    }
    let parent: ReactiveEffect | undefined = activeEffect
    let lastShouldTrack = shouldTrack
    while (parent) {
      if (parent === this) {
        return
      }
      parent = parent.parent
    }
    try {
      this.parent = activeEffect
      activeEffect = this
      shouldTrack = true

      trackOpBit = 1 << ++effectTrackDepth

      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this)
      } else {
        cleanupEffect(this)
      }
      return this.fn()
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this)
      }

      trackOpBit = 1 << --effectTrackDepth

      activeEffect = this.parent
      shouldTrack = lastShouldTrack
      this.parent = undefined

      if (this.deferStop) {
        this.stop()
      }
    }
  }

  stop() {
    // stopped while running itself - defer the cleanup
    if (activeEffect === this) {
      this.deferStop = true
    } else if (this.active) {
      cleanupEffect(this)
      if (this.onStop) {
        this.onStop()
      }
      this.active = false
    }
  }
}

function cleanupEffect(effect: ReactiveEffect) {
  const { deps } = effect
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect)
    }
    deps.length = 0
  }
}
```
ReactiveEffectã®propatyã®ãƒ¡ã‚¤ãƒ³ã®æ©Ÿèƒ½ã¯ä»¥ä¸‹ã®é€šã‚Šã€‚
* fn: ä¾å­˜é–¢ä¿‚ãŒå¤‰æ›´ã•ã‚ŒãŸã¨ãã«å®Ÿè¡Œã•ã‚Œã‚‹é–¢æ•°
* parent: ä¾å­˜ã—ã¦ã„ã‚‹å…ˆã®`ReactiveEffect`
* run():ã€€fnã‚’å®Ÿè¡Œã—ã¦ã‚‚å•é¡Œãªã„ã‹ä¾å­˜é–¢ä¿‚ã‚’ç¢ºèªã—ã€å®Ÿè¡Œã§ãã‚‹ãƒ»ã™ã¹ãã§ã‚ã‚‹å ´åˆã«acctiveEffectã«thisã‚’ç™»éŒ²ã—ã€fn()ã‚’å®Ÿè¡Œã™ã‚‹ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€fnå†…ã§ã®refã¸ã®ã€€getterã‚¢ã‚¯ã‚»ã‚¹ãŒã‚ã‚Œã°ã€this(activeEffect)ãŒã‚¢ã‚¯ã‚»ã‚¹ã—ãŸrefã®depã«ç™»éŒ²ã•ã‚Œã‚‹ã€‚

ãã‚Œã§ã¯ä»Šã¾ã§èª­ã‚“ã ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’è¸ã¾ãˆã¦ã€ReactiveEffectã®ç°¡æ˜“ç‰ˆï¼‹watchEffectã‚’æ›¸ã„ã¦ã¿ã¾ã™ã€‚
```myref.ts
let activeEffect: ReactiveEffect | undefined;

class ReactiveEffect<T = any> {
  constructor(public fn: () => T) {
  }
  run() {
    activeEffect = this;
    return this.fn();
  }
}

function myWatchEffect(fn:()=>any):void {
    const effect = new ReactiveEffect(fn)    
    effect.run()
    activeEffect = undefined;
}
```
ã“ã‚Œã§ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã®å®Ÿç¾ã«å¿…è¦ãªã‚¢ã‚¤ãƒ†ãƒ ã¯å…¨ã¦æƒã„ã¾ã—ãŸã€‚å®Ÿéš›ã«ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãŒå®Ÿè£…ã§ãã¦ã„ã‚‹ã‹ã©ã†ã‹ã€ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã§ãƒ†ã‚¹ãƒˆã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```ts
const msg = ref<string>("hello!")

myWatchEffect(()=>console.log("I am tracking ",msg.value)) // I am tracking hello!

msg.value = "changed!" // I am tracking changed!
```
`msg`å¤‰æ•°ã®æ›´æ–°ã«ã‚ˆã£ã¦console.logãŒï¼’å›è¡Œã‚ã‚Œã€reactivityã®å®Ÿè£…ãŒã§ãã¦ã„ã‚‹ã“ã¨ãŒç¢ºã‹ã‚ã‚‰ã‚Œã¾ã—ãŸï¼ã‚„ã£ãŸã­ğŸ‘
# ã‚³ãƒ¼ãƒ‰å…¨æ–‡
ç°¡æ˜“ç‰ˆã‚³ãƒ¼ãƒ‰å…¨æ–‡ã‚’æ²è¼‰ã—ã¦ãŠãã¾ã™ã€‚
```myref.ts
type Dep = Set<ReactiveEffect>;
let activeEffect: ReactiveEffect | undefined;

class ReactiveEffect<T = any> {
  constructor(public fn: () => T) {
  }
  run() {
    activeEffect = this;
    return this.fn();
  }
}

function ref<T>(value: T) {
    return new RefImpl(value);
}

class RefImpl<T> {
  private _value: T;
  public dep: Dep = new Set();

  constructor(value: T) {
    this._value = value;
  }

  get value() {
    trackEffects(this.dep);
    return this._value;
  }

  set value(newVal) {
    this._value = newVal;
    triggerEffects(this.dep);
  }
}

function trackEffects(dep: Dep) {
  if (activeEffect) dep.add(activeEffect);
}

function triggerEffects(dep: Dep) {
  for (const effect of dep) {
    effect.run();
  }
}

function myWatchEffect(fn:()=>any):void {
    const effect = new ReactiveEffect(fn)
    effect.run()
    activeEffect = undefined;
}

const msg = ref<string>("hello!")

myWatchEffect(()=>console.log("I am tracking ",msg.value))

msg.value = "changed!"
```

# ã¾ã¨ã‚
å®Ÿéš›ã«ã‚³ãƒ¼ãƒ‰ã‚’èª­ã¿ã¤ã¤ç°¡æ˜“ç‰ˆã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã§vueã«ãŠã‘ã‚‹refã®å®Ÿè£…ãŒã©ã®ã‚ˆã†ã«ãªã£ã¦ã„ã‚‹ã®ã‹ã‚’ç†è§£ã™ã‚‹ã“ã¨ãŒã§ãã¾ã—ãŸã€‚reactiveã€computedã‚„watchã«ã¤ã„ã¦ã‚‚è‡ªåŠ›ã§ç°¡æ˜“ç‰ˆã‚’å®Ÿè£…ã—ãŸã„ã§ã™ã€‚

# å‚è€ƒ
https://ja.vuejs.org/guide/extras/reactivity-in-depth.html#how-reactivity-works-in-vue

https://www.vuemastery.com/courses/vue-3-reactivity/vue3-reactivity

